{"version":3,"sources":["Point.js","Map.js","Radians.js","components/minimap.jsx","Ray.js","Player.js","components/column.jsx","components/scene.jsx","hooks/useKeyPressing.js","hooks/useImmutableStateReducer.js","hooks/useAnimationFrame.js","components/app.jsx","index.js","hooks/useCastRays.js"],"names":["Point","x","y","this","Map","height","size","grid","toGrid","point","unitsPerGrid","Math","floor","prototype","add","distance","other","hypot","isWall","gridCoordinates","isWithinBounds","twoPi","PI","fromDegrees","degrees","Minimap","React","Component","wallsRef","createRef","playerRef","raysRef","componentDidMount","drawWalls","drawPlayer","drawRays","context","current","getContext","props","map","cellSize","fillStyle","forEach","row","cell","fillRect","player","position","gridX","gridY","minimapX","minimapY","clearRect","beginPath","arc","fill","rays","strokeStyle","i","length","angle","origin","gridDistance","mapDistance","moveTo","lineTo","cos","sin","stroke","componentDidUpdate","prevProps","render","style","styles","container","ref","width","layer","top","left","Ray","radians","newAngle","normalize","up","right","horizontalDistance","intersectionY","intersection","tan","deltaY","deltaX","abs","findWall","castHorizontal","verticalDistance","intersectionX","castVertical","min","cast","Infinity","Player","direction","adjustDelta","proposed","delta","castRays","fov","resolution","angleBetweenRays","startAngle","Array","_","index","turnRight","elapsed","turnLeft","moveForward","moveBackward","moveLeft","moveRight","Column","color","mapHeight","number","screenHeight","screenWidth","backgroundColor","Color","darken","hex","Scene","containerStyles","useMemo","ceiling","ray","adjustDistance","key","border","bottom","reducer","state","action","type","useKeyPressing","handlers","andThen","initialState","useReducer","dispatch","stateRef","useRef","useEffect","useImmutableStateReducer","callback","frameRef","timestampRef","window","performance","now","requestAnimationFrame","loop","timestamp","cancelAnimationFrame","useAnimationFrame","useCallback","isPressingKey","value","keyNames","Object","keys","handleKeyDown","event","includes","code","preventDefault","handleKeyUp","document","addEventListener","removeEventListener","display","ReactDOM","createElement","useState","showMinimap","setShowMinimap","setRays","newRays","KeyW","KeyS","KeyA","KeyD","ArrowLeft","ArrowRight","useCastRays","htmlFor","id","onChange","checked","href","getElementById"],"mappings":"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","file":"static/js/main.85f564b6.chunk.js","sourcesContent":["export default function Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\n// Return a new point with the values incremented by the passed-in values.\nPoint.prototype.add = function (x, y) {\n  return new Point(this.x + x, this.y + y);\n};\n\n// Return the distance between this point and another.\nPoint.prototype.distance = function (other) {\n  return Math.hypot(this.x - other.x, this.y - other.y);\n};\n","/* eslint-disable no-extend-native */\n\nimport Point from './Point';\n\nexport default function Map(height) {\n  this.height = height;\n  this.size = 10;\n  this.grid = [\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n    [1, 0, 0, 0, 1, 1, 1, 1, 0, 1],\n    [1, 0, 0, 0, 0, 0, 0, 1, 0, 1],\n    [1, 0, 0, 0, 0, 1, 0, 1, 0, 1],\n    [1, 0, 0, 0, 0, 1, 1, 1, 0, 1],\n    [1, 0, 1, 0, 0, 0, 0, 0, 0, 1],\n    [1, 0, 1, 1, 0, 0, 0, 0, 0, 1],\n    [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  ];\n}\n\nMap.prototype.isWall = function (point) {\n  const gridCoordinates = toGrid(point, this.height);\n  return this.isWithinBounds(point) && this.grid[gridCoordinates.y][gridCoordinates.x] === 1;\n};\n\nMap.prototype.isWithinBounds = function (point) {\n  const gridCoordinates = toGrid(point, this.height);\n  return gridCoordinates.x >= 0 && gridCoordinates.x < this.size && gridCoordinates.y >= 0 && gridCoordinates.y < this.size;\n};\n\n// Convert unit coordinates to grid coordinates. Each grid coordinate can be broken up into\n// some number of smaller \"unit\" coordinates.\nfunction toGrid(point, unitsPerGrid) {\n  return new Point(Math.floor(point.x / unitsPerGrid), Math.floor(point.y / unitsPerGrid));\n}\n","export const twoPi = 2 * Math.PI;\n\n// Convert degrees to radians.\nexport function fromDegrees(degrees) {\n  return degrees * Math.PI / 180;\n}\n\n// Ensure that radians are between 0 and 2π.\nexport function normalize(radians) {\n  const newAngle = radians % twoPi;\n  return newAngle < 0 ? newAngle + twoPi : newAngle;\n}\n","import React from 'react';\nimport { twoPi } from '../Radians';\n\nexport default class Minimap extends React.Component {\n  wallsRef = React.createRef()\n  playerRef = React.createRef()\n  raysRef = React.createRef()\n\n  componentDidMount() {\n    this.drawWalls();\n    this.drawPlayer();\n    this.drawRays();\n  }\n\n  drawWalls() {\n    const context = this.wallsRef.current.getContext('2d');\n    const { map, size } = this.props;\n    const cellSize = size / map.size;\n\n    context.fillStyle = 'blue';\n\n    map.grid.forEach((row, y) => {\n      row.forEach((cell, x) => {\n        if (cell === 1) {\n          context.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);\n        }\n      });\n    });\n  }\n\n  drawPlayer() {\n    const context = this.playerRef.current.getContext('2d');\n    const { map, player, size } = this.props;\n    const { position } = player;\n    const gridX = position.x / map.height;\n    const gridY = position.y / map.height;\n    const cellSize = size / map.size;\n    const minimapX = gridX * cellSize;\n    const minimapY = gridY * cellSize;\n\n    context.clearRect(0, 0, size, size);\n    context.fillStyle = 'green';\n    context.beginPath();\n    context.arc(minimapX, minimapY, 5, 0, twoPi);\n    context.fill();\n  }\n\n  drawRays() {\n    const context = this.raysRef.current.getContext('2d');\n    const { map, rays, size } = this.props;\n    const cellSize = size / map.size;\n\n    context.clearRect(0, 0, size, size);\n    context.beginPath();\n    context.strokeStyle = 'green';\n\n    for (let i = 0; i < rays.length; i += 16) {\n      const { angle, distance, origin } = rays[i];\n      const gridX = origin.x / map.height;\n      const gridY = origin.y / map.height;\n      const gridDistance = distance / map.height;\n      const minimapX = gridX * cellSize;\n      const minimapY = gridY * cellSize;\n      const mapDistance = (size / map.size) * gridDistance;\n\n      context.moveTo(minimapX, minimapY);\n      context.lineTo(minimapX + mapDistance * Math.cos(angle), minimapY + mapDistance * -Math.sin(angle));\n      context.stroke();\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.rays !== this.props.rays) {\n      this.drawPlayer();\n      this.drawRays();\n    }\n  }\n\n  render() {\n    const { size } = this.props;\n    return (\n      <div style={styles.container}>\n        <canvas ref={this.wallsRef} height={size} width={size} style={styles.layer} />\n        <canvas ref={this.playerRef} height={size} width={size} style={styles.layer} />\n        <canvas ref={this.raysRef} height={size} width={size} style={styles.layer} />\n      </div>\n    );\n  }\n}\n\nconst styles = {\n  container: {\n    position: 'relative',\n  },\n  layer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n  },\n};\n","import Point from './Point';\nimport { normalize, twoPi } from './Radians';\n\nexport default function Ray(map, angle, origin) {\n  this.origin = origin;\n  this.angle = normalize(angle);\n  this.distance = cast(map, this.angle, origin);\n}\n\n// Determine the distance travelled before hitting a wall.\nfunction cast(map, angle, origin) {\n  // Determine the direction the ray is travelling.\n  const up = angle > 0 && angle < Math.PI;\n  const right = angle < (twoPi * 0.25) || angle > (twoPi * 0.75);\n\n  // Determine the distance to the first horizontal wall.\n  const horizontalDistance = castHorizontal(map, origin, angle, up, right);\n\n  // Determine the distance to the first vertical wall.\n  const verticalDistance = castVertical(map, origin, angle, up, right);\n\n  // Return the shortest distance between the horizontal and vertical distances.\n  return Math.min(horizontalDistance, verticalDistance);\n}\n\n// Determine the distance travelled before hitting a _horizontal_ wall.\nfunction castHorizontal(map, origin, angle, up, right) {\n  // Calculate the coordinates of the first intersection with a grid boundary.\n  const intersectionY = Math.floor(origin.y / map.height) * map.height + (up ? -0.01 : map.height);\n  const intersectionX = origin.x + (origin.y - intersectionY) / Math.tan(angle);\n  const intersection = new Point(intersectionX, intersectionY);\n\n  // Calculate the change in x and y coordinates needed to iterate across grid boundaries.\n  const deltaY = up ? -map.height : map.height;\n  const deltaX = Math.abs(map.height / Math.tan(angle)) * (right ? 1 : -1);\n\n  // Find the nearest wall and return the distance to it.\n  const wall = findWall(map, intersection, deltaX, deltaY);\n  return wall.distance(origin);\n}\n\n// Determine the distance travelled before hitting a _vertical_ wall.\nfunction castVertical(map, origin, angle, up, right) {\n  // Calculate the coordinates of the first intersection with a grid boundary.\n  const intersectionX = Math.floor(origin.x / map.height) * map.height + (right ? map.height : -0.01);\n  const intersectionY = origin.y + (origin.x - intersectionX) * Math.tan(angle);\n  const intersection = new Point(intersectionX, intersectionY);\n\n  // Calculate the change in x and y coordinates needed to iterate across grid boundaries.\n  const deltaX = right ? map.height : -map.height;\n  const deltaY = Math.abs(map.height * Math.tan(angle)) * (up ? -1 : 1);\n\n  // Find the nearest wall and return the distance to it.\n  const wall = findWall(map, intersection, deltaX, deltaY);\n  return wall.distance(origin);\n}\n\n// Process each step the ray takes until encountering a wall or the bounds of the map.\nfunction findWall(map, position, deltaX, deltaY) {\n  // If the ray is no longer within the bounds of the map, return a point infinitely far away.\n  if (!map.isWithinBounds(position)) {\n    return new Point(Infinity, Infinity);\n  }\n\n  // If the ray has hit a wall, return its position.\n  if (map.isWall(position)) {\n    return position;\n  }\n\n  // No wall has been encountered. Iterate to the next grid boundary and check again.\n  return findWall(map, position.add(deltaX, deltaY), deltaX, deltaY);\n}\n","import Point from './Point';\nimport Ray from './Ray';\n\nconst stepDistance = 1.4; // per 16ms\nconst turnRotation = 0.025; // per 16ms\n\nexport default function Player(x, y, direction) {\n  this.position = new Point(x, y);\n  this.direction = direction;\n}\n\n// Determine the distance to walls the user can see by casting rays of light from the player's\n// eyes and figuring out where they intersect with a wall. The `resolution` is the number of rays\n// to cast, and `fov` determines how spread apart they will be.\nPlayer.prototype.castRays = function (map, fov, resolution) {\n  // If the field of view is 60 degrees and the resolution is 320, there is 60 / 320 degrees\n  // between each ray.\n  const angleBetweenRays = fov / resolution;\n\n  // The player's direction is the center of the screen, and the left edge of the screen is half\n  // the field of view to the left. In our coordinate system, angles increase as we turn counter-\n  // clockwise, so we add to player's current direction.\n  const startAngle = this.direction + fov / 2;\n\n  // Generate the angle for each ray starting from the left and sweeping to the right screen edge.\n  const rayAngles = new Array(resolution).fill(0).map((_, index) => startAngle - index * angleBetweenRays);\n\n  // Calculate the distance from each ray to the nearest wall.\n  return rayAngles.map(angle => new Ray(map, angle, this.position));\n};\n\nPlayer.prototype.turnRight = function (elapsed) {\n  this.direction -= turnRotation * elapsed / 16;\n};\n\nPlayer.prototype.turnLeft = function (elapsed) {\n  this.direction += turnRotation * elapsed / 16;\n};\n\nPlayer.prototype.moveForward = function (map, elapsed) {\n  const deltaX = stepDistance * (elapsed / 16) * Math.cos(this.direction);\n  const deltaY = stepDistance * (elapsed / 16) * Math.sin(this.direction);\n\n  this.position = this.position.add(\n    adjustDelta(map, this.position.add(deltaX, 0), deltaX),\n    adjustDelta(map, this.position.add(0, -deltaY), -deltaY),\n  );\n};\n\nPlayer.prototype.moveBackward = function (map, elapsed) {\n  const deltaX = stepDistance * (elapsed / 16) * Math.cos(this.direction);\n  const deltaY = stepDistance * (elapsed / 16) * Math.sin(this.direction);\n\n  this.position = this.position.add(\n    adjustDelta(map, this.position.add(-deltaX, 0), -deltaX),\n    adjustDelta(map, this.position.add(0, deltaY), deltaY),\n  );\n};\n\n// Step to the left, which is the same as stepping forward but rotated 90 degrees to the left.\nPlayer.prototype.moveLeft = function (map, elapsed) {\n  const deltaX = stepDistance * (elapsed / 16) * Math.cos(this.direction + Math.PI / 2);\n  const deltaY = stepDistance * (elapsed / 16) * Math.sin(this.direction + Math.PI / 2);\n\n  this.position = this.position.add(\n    adjustDelta(map, this.position.add(deltaX, 0), deltaX),\n    adjustDelta(map, this.position.add(0, -deltaY), -deltaY),\n  );\n};\n\n// Step to the right, which is the same as stepping backward but rotated 90 degrees to the left.\nPlayer.prototype.moveRight = function (map, elapsed) {\n  const deltaX = stepDistance * (elapsed / 16) * Math.cos(this.direction + Math.PI / 2);\n  const deltaY = stepDistance * (elapsed / 16) * Math.sin(this.direction + Math.PI / 2);\n\n  this.position = this.position.add(\n    adjustDelta(map, this.position.add(-deltaX, 0), -deltaX),\n    adjustDelta(map, this.position.add(0, deltaY), deltaY),\n  );\n};\n\n// Perform collision-detection to determine if a proposed new position for the player is a valid\n// one. If it is, return the proposed delta. Otherwise, return 0.\nfunction adjustDelta(map, proposed, delta) {\n  return map.isWall(proposed) ? 0 : delta;\n}\n","import Color from 'color';\nimport React from 'react';\n\nexport default function Column({\n  color,\n  distance,\n  mapHeight,\n  number,\n  resolution,\n  screenHeight,\n  screenWidth,\n}) {\n  const height = Math.min(mapHeight / distance * 255, screenHeight);\n  const width = screenWidth / resolution;\n  const top = (screenHeight - height) / 2;\n  const adjustedColor = Color(color).darken(distance / 460).hex();\n  const styles = {\n    backgroundColor: adjustedColor,\n    height,\n    left: number * width,\n    width,\n    position: 'absolute',\n    top,\n  };\n\n  return <div style={styles} />;\n}\n","import React, { useMemo } from 'react';\nimport Column from './column';\n\nexport default function Scene({\n  height,\n  mapHeight,\n  player,\n  rays,\n  resolution,\n  width,\n}) {\n  const containerStyles = useMemo(() => ({ ...styles.container, height, width }), [height, width]);\n\n  return (\n    <div style={containerStyles}>\n      <div style={styles.ceiling} />\n      <div style={styles.floor} />\n      {rays.map((ray, index) => (\n        <Column\n          color=\"#0000FF\"\n          distance={adjustDistance(ray, player)}\n          key={index} // eslint-disable-line react/no-array-index-key\n          mapHeight={mapHeight}\n          number={index}\n          resolution={resolution}\n          screenHeight={height}\n          screenWidth={width}\n        />\n      ))}\n    </div>\n  );\n}\n\n// Correct for a fishbowl-effect resulting from mixing polar and cartesian coordinates.\nfunction adjustDistance(ray, player) {\n  return ray.distance * Math.cos(ray.angle - player.direction);\n}\n\nconst styles = {\n  container: {\n    border: '1px solid black',\n    position: 'relative',\n  },\n  ceiling: {\n    backgroundColor: 'SlateGrey',\n    position: 'absolute',\n    left: 0,\n    right: 0,\n    bottom: '50%',\n    top: 0,\n  },\n  floor: {\n    backgroundColor: 'Gainsboro',\n    position: 'absolute',\n    left: 0,\n    right: 0,\n    bottom: 0,\n    top: '50%',\n  },\n};\n","import forEach from 'lodash.foreach';\nimport { useCallback, useEffect } from 'react';\nimport useAnimationFrame from './useAnimationFrame';\nimport useImmutableStateReducer from './useImmutableStateReducer';\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'down':\n      return { ...state, [action.key]: true };\n    case 'up':\n      return { ...state, [action.key]: false };\n    default:\n      return state;\n  }\n}\n\nexport default function useKeyPressing(handlers, { andThen = () => {} }) {\n  const [stateRef, dispatch] = useImmutableStateReducer(reducer, {});\n\n  useAnimationFrame(\n    useCallback(\n      (elapsed) => {\n        let isPressingKey = false;\n\n        // Execute the handler for all keys that are being pressed.\n        forEach(handlers, (value, key) => {\n          if (stateRef.current[key]) {\n            isPressingKey = true;\n            value(elapsed);\n          }\n        });\n\n        if (isPressingKey) { andThen(); }\n      },\n      [stateRef, handlers, andThen],\n    ),\n  );\n\n  useEffect(() => {\n    const keyNames = Object.keys(handlers);\n\n    function handleKeyDown(event) {\n      if (keyNames.includes(event.code)) {\n        event.preventDefault();\n        dispatch({ type: 'down', key: event.code });\n      }\n    }\n\n    function handleKeyUp(event) {\n      if (keyNames.includes(event.code)) {\n        event.preventDefault();\n        dispatch({ type: 'up', key: event.code });\n      }\n    }\n\n    document.addEventListener('keydown', handleKeyDown);\n    document.addEventListener('keyup', handleKeyUp);\n\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.removeEventListener('keyup', handleKeyUp);\n    };\n  }, [handlers, dispatch]);\n}\n","import { useEffect, useReducer, useRef } from 'react';\n\nexport default function useImmutableStateReducer(reducer, initialState) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const stateRef = useRef(state);\n\n  useEffect(() => {\n    stateRef.current = state;\n  }, [state]);\n\n  return [stateRef, dispatch];\n}\n","import { useEffect, useRef } from 'react';\n\nexport default function useAnimationFrame(callback) {\n  const frameRef = useRef();\n  const timestampRef = useRef();\n\n  useEffect(() => {\n    timestampRef.current = window.performance.now();\n  }, []);\n\n  useEffect(() => {\n    function loop(timestamp) {\n      frameRef.current = requestAnimationFrame(loop);\n      callback(timestamp - timestampRef.current);\n      timestampRef.current = timestamp;\n    };\n\n    frameRef.current = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(frameRef.current);\n  }, [callback]);\n};\n","import React, { useState } from 'react';\nimport Map from '../Map';\nimport Minimap from './minimap';\nimport Player from '../Player';\nimport Scene from './scene';\nimport useCastRays from '../hooks/useCastRays';\nimport { fromDegrees } from '../Radians';\n\nconst fov = fromDegrees(60);\nconst map = new Map(64);\nconst player = new Player(160, 160, fromDegrees(0));\nconst resolution = 320;\n\nexport default function App() {\n  const [showMinimap, setShowMinimap] = useState(true);\n  const rays = useCastRays(player, map, fov, resolution);\n\n  return (\n    <div style={styles.container}>\n      <div>\n        <Scene\n          height={400}\n          mapHeight={map.height}\n          player={player}\n          rays={rays}\n          resolution={resolution}\n          width={740}\n        />\n        <div>\n          <span>Move using the w, s, a, d, ←, and → keys</span>\n          <div>\n            <label htmlFor=\"show_minimap\">\n              Show minimap\n              <input id=\"show_minimap\" onChange={() => setShowMinimap(!showMinimap)} type=\"checkbox\" checked={showMinimap} />\n            </label>\n          </div>\n          <a href=\"https://github.com/ahuth/raycast\">Source code</a>\n        </div>\n      </div>\n      {showMinimap && (\n        <Minimap\n          fov={fov}\n          map={map}\n          player={player}\n          rays={rays}\n          resolution={resolution}\n          size={300}\n        />\n      )}\n    </div>\n  );\n}\n\nconst styles = {\n  container: {\n    display: 'flex',\n  },\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/app';\nimport './index.css';\n\nReactDOM.render(React.createElement(App), document.getElementById('root'));\n","import { useCallback, useEffect, useMemo, useState } from 'react';\nimport useKeyPressing from './useKeyPressing';\n\nexport default function useCastRays(player, map, fov, resolution) {\n  const [rays, setRays] = useState([]);\n\n  const castRays = useCallback(() => {\n    const newRays = player.castRays(map, fov, resolution);\n    setRays(newRays);\n  }, [player, map, fov, resolution]);\n\n  useEffect(() => { castRays(); }, [castRays]);\n\n  useKeyPressing(\n    useMemo(\n      () => {\n        return {\n          KeyW: (elapsed) => { player.moveForward(map, elapsed); },\n          KeyS: (elapsed) => { player.moveBackward(map, elapsed); },\n          KeyA: (elapsed) => { player.moveLeft(map, elapsed); },\n          KeyD: (elapsed) => { player.moveRight(map, elapsed); },\n          ArrowLeft: (elapsed) => { player.turnLeft(elapsed); },\n          ArrowRight: (elapsed) => { player.turnRight(elapsed); },\n        };\n      },\n      [player, map],\n    ),\n    { andThen: castRays },\n  );\n\n  return rays;\n}\n"],"sourceRoot":""}